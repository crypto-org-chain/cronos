// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: attestation/v1/events.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventBlockAttested is emitted when a block attestation is processed
type EventBlockAttested struct {
	// Attestation ID
	AttestationId uint64 `protobuf:"varint,1,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
	// Source chain ID
	ChainId string `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Block height that was attested
	BlockHeight uint64 `protobuf:"varint,3,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// Relayer who submitted the attestation
	Relayer string `protobuf:"bytes,4,opt,name=relayer,proto3" json:"relayer,omitempty"`
	// Whether the block achieved finality
	Finalized bool `protobuf:"varint,5,opt,name=finalized,proto3" json:"finalized,omitempty"`
	// Finality proof (validator signatures, etc.)
	FinalityProof []byte `protobuf:"bytes,6,opt,name=finality_proof,json=finalityProof,proto3" json:"finality_proof,omitempty"`
	// Timestamp when attestation was processed
	ProcessedAt int64 `protobuf:"varint,7,opt,name=processed_at,json=processedAt,proto3" json:"processed_at,omitempty"`
}

func (m *EventBlockAttested) Reset()         { *m = EventBlockAttested{} }
func (m *EventBlockAttested) String() string { return proto.CompactTextString(m) }
func (*EventBlockAttested) ProtoMessage()    {}
func (*EventBlockAttested) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae226af17978ceef, []int{0}
}
func (m *EventBlockAttested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBlockAttested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBlockAttested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBlockAttested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBlockAttested.Merge(m, src)
}
func (m *EventBlockAttested) XXX_Size() int {
	return m.Size()
}
func (m *EventBlockAttested) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBlockAttested.DiscardUnknown(m)
}

var xxx_messageInfo_EventBlockAttested proto.InternalMessageInfo

func (m *EventBlockAttested) GetAttestationId() uint64 {
	if m != nil {
		return m.AttestationId
	}
	return 0
}

func (m *EventBlockAttested) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *EventBlockAttested) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EventBlockAttested) GetRelayer() string {
	if m != nil {
		return m.Relayer
	}
	return ""
}

func (m *EventBlockAttested) GetFinalized() bool {
	if m != nil {
		return m.Finalized
	}
	return false
}

func (m *EventBlockAttested) GetFinalityProof() []byte {
	if m != nil {
		return m.FinalityProof
	}
	return nil
}

func (m *EventBlockAttested) GetProcessedAt() int64 {
	if m != nil {
		return m.ProcessedAt
	}
	return 0
}

// EventBlockFinalized is emitted when a block reaches finality on attestation layer
type EventBlockFinalized struct {
	// Source chain ID
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Block height that achieved finality
	BlockHeight uint64 `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// Finality timestamp
	FinalizedAt int64 `protobuf:"varint,3,opt,name=finalized_at,json=finalizedAt,proto3" json:"finalized_at,omitempty"`
	// Number of validators that attested
	ValidatorCount uint32 `protobuf:"varint,4,opt,name=validator_count,json=validatorCount,proto3" json:"validator_count,omitempty"`
	// Aggregate signature or proof of finality
	FinalitySignature []byte `protobuf:"bytes,5,opt,name=finality_signature,json=finalitySignature,proto3" json:"finality_signature,omitempty"`
	// Transaction hash where finality was confirmed
	AttestationTxHash []byte `protobuf:"bytes,6,opt,name=attestation_tx_hash,json=attestationTxHash,proto3" json:"attestation_tx_hash,omitempty"`
}

func (m *EventBlockFinalized) Reset()         { *m = EventBlockFinalized{} }
func (m *EventBlockFinalized) String() string { return proto.CompactTextString(m) }
func (*EventBlockFinalized) ProtoMessage()    {}
func (*EventBlockFinalized) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae226af17978ceef, []int{1}
}
func (m *EventBlockFinalized) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBlockFinalized) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBlockFinalized.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBlockFinalized) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBlockFinalized.Merge(m, src)
}
func (m *EventBlockFinalized) XXX_Size() int {
	return m.Size()
}
func (m *EventBlockFinalized) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBlockFinalized.DiscardUnknown(m)
}

var xxx_messageInfo_EventBlockFinalized proto.InternalMessageInfo

func (m *EventBlockFinalized) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *EventBlockFinalized) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *EventBlockFinalized) GetFinalizedAt() int64 {
	if m != nil {
		return m.FinalizedAt
	}
	return 0
}

func (m *EventBlockFinalized) GetValidatorCount() uint32 {
	if m != nil {
		return m.ValidatorCount
	}
	return 0
}

func (m *EventBlockFinalized) GetFinalitySignature() []byte {
	if m != nil {
		return m.FinalitySignature
	}
	return nil
}

func (m *EventBlockFinalized) GetAttestationTxHash() []byte {
	if m != nil {
		return m.AttestationTxHash
	}
	return nil
}

// EventForcedTxSubmitted is emitted when a forced transaction is submitted
type EventForcedTxSubmitted struct {
	// Forced transaction ID
	ForcedTxId uint64 `protobuf:"varint,1,opt,name=forced_tx_id,json=forcedTxId,proto3" json:"forced_tx_id,omitempty"`
	// Submitter address
	Submitter string `protobuf:"bytes,2,opt,name=submitter,proto3" json:"submitter,omitempty"`
	// Target chain ID
	TargetChainId string `protobuf:"bytes,3,opt,name=target_chain_id,json=targetChainId,proto3" json:"target_chain_id,omitempty"`
	// Target chain type
	TargetChainType string `protobuf:"bytes,4,opt,name=target_chain_type,json=targetChainType,proto3" json:"target_chain_type,omitempty"`
	// Priority level
	Priority uint32 `protobuf:"varint,5,opt,name=priority,proto3" json:"priority,omitempty"`
	// Transaction type
	TxType ForcedTxType `protobuf:"varint,6,opt,name=tx_type,json=txType,proto3,enum=attestation.v1.ForcedTxType" json:"tx_type,omitempty"`
	// Deadline block height
	Deadline uint64 `protobuf:"varint,7,opt,name=deadline,proto3" json:"deadline,omitempty"`
	// Timestamp when submitted
	SubmittedAt int64 `protobuf:"varint,8,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at,omitempty"`
}

func (m *EventForcedTxSubmitted) Reset()         { *m = EventForcedTxSubmitted{} }
func (m *EventForcedTxSubmitted) String() string { return proto.CompactTextString(m) }
func (*EventForcedTxSubmitted) ProtoMessage()    {}
func (*EventForcedTxSubmitted) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae226af17978ceef, []int{2}
}
func (m *EventForcedTxSubmitted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventForcedTxSubmitted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventForcedTxSubmitted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventForcedTxSubmitted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventForcedTxSubmitted.Merge(m, src)
}
func (m *EventForcedTxSubmitted) XXX_Size() int {
	return m.Size()
}
func (m *EventForcedTxSubmitted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventForcedTxSubmitted.DiscardUnknown(m)
}

var xxx_messageInfo_EventForcedTxSubmitted proto.InternalMessageInfo

func (m *EventForcedTxSubmitted) GetForcedTxId() uint64 {
	if m != nil {
		return m.ForcedTxId
	}
	return 0
}

func (m *EventForcedTxSubmitted) GetSubmitter() string {
	if m != nil {
		return m.Submitter
	}
	return ""
}

func (m *EventForcedTxSubmitted) GetTargetChainId() string {
	if m != nil {
		return m.TargetChainId
	}
	return ""
}

func (m *EventForcedTxSubmitted) GetTargetChainType() string {
	if m != nil {
		return m.TargetChainType
	}
	return ""
}

func (m *EventForcedTxSubmitted) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *EventForcedTxSubmitted) GetTxType() ForcedTxType {
	if m != nil {
		return m.TxType
	}
	return ForcedTxTypeNormal
}

func (m *EventForcedTxSubmitted) GetDeadline() uint64 {
	if m != nil {
		return m.Deadline
	}
	return 0
}

func (m *EventForcedTxSubmitted) GetSubmittedAt() int64 {
	if m != nil {
		return m.SubmittedAt
	}
	return 0
}

// EventForcedTxExecuted is emitted when relayer confirms forced transaction execution
type EventForcedTxExecuted struct {
	// Forced transaction ID
	ForcedTxId uint64 `protobuf:"varint,1,opt,name=forced_tx_id,json=forcedTxId,proto3" json:"forced_tx_id,omitempty"`
	// Target chain ID where it was executed
	TargetChainId string `protobuf:"bytes,2,opt,name=target_chain_id,json=targetChainId,proto3" json:"target_chain_id,omitempty"`
	// Execution transaction hash on target chain
	ExecutionTxHash []byte `protobuf:"bytes,3,opt,name=execution_tx_hash,json=executionTxHash,proto3" json:"execution_tx_hash,omitempty"`
	// Block height where it was executed
	ExecutionHeight uint64 `protobuf:"varint,4,opt,name=execution_height,json=executionHeight,proto3" json:"execution_height,omitempty"`
	// Relayer who executed it
	Relayer string `protobuf:"bytes,5,opt,name=relayer,proto3" json:"relayer,omitempty"`
	// Timestamp when executed
	ExecutedAt int64 `protobuf:"varint,6,opt,name=executed_at,json=executedAt,proto3" json:"executed_at,omitempty"`
}

func (m *EventForcedTxExecuted) Reset()         { *m = EventForcedTxExecuted{} }
func (m *EventForcedTxExecuted) String() string { return proto.CompactTextString(m) }
func (*EventForcedTxExecuted) ProtoMessage()    {}
func (*EventForcedTxExecuted) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae226af17978ceef, []int{3}
}
func (m *EventForcedTxExecuted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventForcedTxExecuted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventForcedTxExecuted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventForcedTxExecuted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventForcedTxExecuted.Merge(m, src)
}
func (m *EventForcedTxExecuted) XXX_Size() int {
	return m.Size()
}
func (m *EventForcedTxExecuted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventForcedTxExecuted.DiscardUnknown(m)
}

var xxx_messageInfo_EventForcedTxExecuted proto.InternalMessageInfo

func (m *EventForcedTxExecuted) GetForcedTxId() uint64 {
	if m != nil {
		return m.ForcedTxId
	}
	return 0
}

func (m *EventForcedTxExecuted) GetTargetChainId() string {
	if m != nil {
		return m.TargetChainId
	}
	return ""
}

func (m *EventForcedTxExecuted) GetExecutionTxHash() []byte {
	if m != nil {
		return m.ExecutionTxHash
	}
	return nil
}

func (m *EventForcedTxExecuted) GetExecutionHeight() uint64 {
	if m != nil {
		return m.ExecutionHeight
	}
	return 0
}

func (m *EventForcedTxExecuted) GetRelayer() string {
	if m != nil {
		return m.Relayer
	}
	return ""
}

func (m *EventForcedTxExecuted) GetExecutedAt() int64 {
	if m != nil {
		return m.ExecutedAt
	}
	return 0
}

// EventBatchBlockAttested is emitted for batch attestations
type EventBatchBlockAttested struct {
	// Source chain ID
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Starting block height
	StartHeight uint64 `protobuf:"varint,2,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// Ending block height
	EndHeight uint64 `protobuf:"varint,3,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	// Number of blocks in batch
	BlockCount uint32 `protobuf:"varint,4,opt,name=block_count,json=blockCount,proto3" json:"block_count,omitempty"`
	// Number of blocks that achieved finality
	FinalizedCount uint32 `protobuf:"varint,5,opt,name=finalized_count,json=finalizedCount,proto3" json:"finalized_count,omitempty"`
	// Relayer who submitted the batch
	Relayer string `protobuf:"bytes,6,opt,name=relayer,proto3" json:"relayer,omitempty"`
	// List of attestation IDs
	AttestationIds []uint64 `protobuf:"varint,7,rep,packed,name=attestation_ids,json=attestationIds,proto3" json:"attestation_ids,omitempty"`
}

func (m *EventBatchBlockAttested) Reset()         { *m = EventBatchBlockAttested{} }
func (m *EventBatchBlockAttested) String() string { return proto.CompactTextString(m) }
func (*EventBatchBlockAttested) ProtoMessage()    {}
func (*EventBatchBlockAttested) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae226af17978ceef, []int{4}
}
func (m *EventBatchBlockAttested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBatchBlockAttested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBatchBlockAttested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBatchBlockAttested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBatchBlockAttested.Merge(m, src)
}
func (m *EventBatchBlockAttested) XXX_Size() int {
	return m.Size()
}
func (m *EventBatchBlockAttested) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBatchBlockAttested.DiscardUnknown(m)
}

var xxx_messageInfo_EventBatchBlockAttested proto.InternalMessageInfo

func (m *EventBatchBlockAttested) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *EventBatchBlockAttested) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *EventBatchBlockAttested) GetEndHeight() uint64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *EventBatchBlockAttested) GetBlockCount() uint32 {
	if m != nil {
		return m.BlockCount
	}
	return 0
}

func (m *EventBatchBlockAttested) GetFinalizedCount() uint32 {
	if m != nil {
		return m.FinalizedCount
	}
	return 0
}

func (m *EventBatchBlockAttested) GetRelayer() string {
	if m != nil {
		return m.Relayer
	}
	return ""
}

func (m *EventBatchBlockAttested) GetAttestationIds() []uint64 {
	if m != nil {
		return m.AttestationIds
	}
	return nil
}

func init() {
	proto.RegisterType((*EventBlockAttested)(nil), "attestation.v1.EventBlockAttested")
	proto.RegisterType((*EventBlockFinalized)(nil), "attestation.v1.EventBlockFinalized")
	proto.RegisterType((*EventForcedTxSubmitted)(nil), "attestation.v1.EventForcedTxSubmitted")
	proto.RegisterType((*EventForcedTxExecuted)(nil), "attestation.v1.EventForcedTxExecuted")
	proto.RegisterType((*EventBatchBlockAttested)(nil), "attestation.v1.EventBatchBlockAttested")
}

func init() { proto.RegisterFile("attestation/v1/events.proto", fileDescriptor_ae226af17978ceef) }

var fileDescriptor_ae226af17978ceef = []byte{
	// 713 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xcd, 0x4e, 0xdb, 0x4a,
	0x14, 0xc6, 0x49, 0x48, 0xc2, 0x21, 0x3f, 0x97, 0xe1, 0xde, 0x8b, 0x2f, 0x97, 0x86, 0x10, 0xa9,
	0x25, 0xad, 0x44, 0x52, 0x5a, 0xf5, 0x01, 0x02, 0x02, 0x41, 0x57, 0x95, 0x61, 0xd5, 0x4d, 0x34,
	0xb1, 0x27, 0xb1, 0xd5, 0xe0, 0xb1, 0xc6, 0x27, 0x91, 0xd3, 0x6d, 0x5f, 0xa0, 0x4f, 0xd4, 0x75,
	0x97, 0x2c, 0xbb, 0xac, 0xe0, 0x11, 0xba, 0xac, 0x54, 0x55, 0x33, 0x63, 0x3b, 0x36, 0xb4, 0xa8,
	0x3b, 0xcf, 0x77, 0x3e, 0x9f, 0x99, 0xef, 0x3b, 0x3f, 0xf0, 0x3f, 0x45, 0x64, 0x21, 0x52, 0xf4,
	0xb8, 0xdf, 0x9f, 0x1f, 0xf6, 0xd9, 0x9c, 0xf9, 0x18, 0xf6, 0x02, 0xc1, 0x91, 0x93, 0x46, 0x26,
	0xd8, 0x9b, 0x1f, 0x6e, 0xff, 0x3d, 0xe1, 0x13, 0xae, 0x42, 0x7d, 0xf9, 0xa5, 0x59, 0xdb, 0x5b,
	0x77, 0x52, 0x60, 0xa4, 0x03, 0x9d, 0xef, 0x06, 0x90, 0x13, 0x99, 0xef, 0x68, 0xca, 0xed, 0x77,
	0x03, 0xc5, 0x62, 0x0e, 0x79, 0x0c, 0xd9, 0xbc, 0x43, 0xcf, 0x31, 0x8d, 0xb6, 0xd1, 0x2d, 0x59,
	0xf5, 0x0c, 0x7a, 0xee, 0x90, 0xff, 0xa0, 0x6a, 0xbb, 0xd4, 0x53, 0x84, 0x42, 0xdb, 0xe8, 0xae,
	0x59, 0x15, 0x75, 0x3e, 0x77, 0xc8, 0x1e, 0xd4, 0x46, 0x32, 0xe5, 0xd0, 0x65, 0xde, 0xc4, 0x45,
	0xb3, 0xa8, 0xfe, 0x5f, 0x57, 0xd8, 0x99, 0x82, 0x88, 0x09, 0x15, 0xc1, 0xa6, 0x74, 0xc1, 0x84,
	0x59, 0xd2, 0x3f, 0xc7, 0x47, 0xb2, 0x03, 0x6b, 0x63, 0xcf, 0xa7, 0x53, 0xef, 0x3d, 0x73, 0xcc,
	0xd5, 0xb6, 0xd1, 0xad, 0x5a, 0x4b, 0x40, 0x3e, 0x4e, 0x1f, 0x70, 0x31, 0x0c, 0x04, 0xe7, 0x63,
	0xb3, 0xdc, 0x36, 0xba, 0x35, 0xab, 0x9e, 0xa0, 0x6f, 0x24, 0x28, 0x5f, 0x10, 0x08, 0x6e, 0xb3,
	0x30, 0x64, 0xce, 0x90, 0xa2, 0x59, 0x69, 0x1b, 0xdd, 0xa2, 0xb5, 0x9e, 0x62, 0x03, 0xec, 0xfc,
	0x30, 0x60, 0x73, 0xa9, 0xfe, 0x34, 0xbd, 0x21, 0xab, 0xcb, 0x78, 0x58, 0x57, 0xe1, 0xbe, 0xae,
	0x3d, 0xa8, 0xa5, 0x8f, 0x95, 0x17, 0x17, 0xf5, 0xc5, 0x29, 0x36, 0x40, 0xb2, 0x0f, 0xcd, 0x39,
	0x9d, 0x7a, 0x0e, 0x45, 0x2e, 0x86, 0x36, 0x9f, 0xf9, 0xa8, 0x2c, 0xa8, 0x5b, 0x8d, 0x14, 0x3e,
	0x96, 0x28, 0x39, 0x00, 0x92, 0x6a, 0x0d, 0xbd, 0x89, 0x4f, 0x71, 0x26, 0x98, 0xb2, 0xa4, 0x66,
	0x6d, 0x24, 0x91, 0x8b, 0x24, 0x40, 0x7a, 0xb0, 0x99, 0xad, 0x1b, 0x46, 0x43, 0x97, 0x86, 0x6e,
	0xec, 0xcf, 0x46, 0x26, 0x74, 0x19, 0x9d, 0xd1, 0xd0, 0xed, 0x7c, 0x2a, 0xc0, 0xbf, 0xca, 0x80,
	0x53, 0x2e, 0x6c, 0xe6, 0x5c, 0x46, 0x17, 0xb3, 0xd1, 0x95, 0x87, 0xb2, 0x05, 0xda, 0x50, 0x1b,
	0x2b, 0x50, 0x66, 0x49, 0x1b, 0x00, 0xc6, 0x31, 0xf1, 0xdc, 0x91, 0x55, 0x0a, 0x63, 0xba, 0x88,
	0xcb, 0xbf, 0x04, 0xc8, 0x13, 0x68, 0x22, 0x15, 0x13, 0x86, 0xc3, 0xd4, 0xca, 0xa2, 0xe2, 0xd4,
	0x35, 0x7c, 0x1c, 0x1b, 0xfa, 0x0c, 0x36, 0x72, 0x3c, 0x5c, 0x04, 0x2c, 0xee, 0x87, 0x66, 0x86,
	0x79, 0xb9, 0x08, 0x18, 0xd9, 0x86, 0x6a, 0x20, 0x3c, 0x2e, 0x3c, 0x5c, 0x28, 0x0f, 0xea, 0x56,
	0x7a, 0x26, 0xaf, 0xa0, 0x82, 0x91, 0xfe, 0x5b, 0xca, 0x6d, 0xbc, 0xd8, 0xe9, 0xe5, 0x47, 0xa3,
	0x97, 0x68, 0x94, 0xa9, 0xac, 0x32, 0x46, 0x49, 0x4a, 0x87, 0x51, 0x67, 0xea, 0xf9, 0x4c, 0x75,
	0x48, 0xc9, 0x4a, 0xcf, 0xb2, 0x90, 0x89, 0x1e, 0x55, 0xc8, 0xaa, 0x2e, 0x64, 0x8a, 0x0d, 0xb0,
	0xf3, 0xcd, 0x80, 0x7f, 0x72, 0x06, 0x9e, 0x44, 0xcc, 0x9e, 0xfd, 0x99, 0x7f, 0xbf, 0x70, 0xa8,
	0xf0, 0x1b, 0x87, 0x98, 0xca, 0x9a, 0x2d, 0x69, 0x51, 0x95, 0xb4, 0x99, 0x06, 0x74, 0x41, 0xc9,
	0x53, 0xf8, 0x6b, 0xc9, 0x8d, 0x5b, 0xb4, 0xa4, 0x6e, 0x5e, 0x52, 0xef, 0x8f, 0xdf, 0x6a, 0x7e,
	0xfc, 0x76, 0x61, 0x9d, 0xc5, 0x32, 0xa4, 0xec, 0xb2, 0x92, 0x0d, 0x09, 0x34, 0xc0, 0xce, 0x87,
	0x02, 0x6c, 0xe9, 0xb9, 0xa1, 0x68, 0xbb, 0xf9, 0xd5, 0xf1, 0xf0, 0xec, 0x84, 0x48, 0x05, 0xde,
	0x99, 0x1d, 0x85, 0xc5, 0x8f, 0x7a, 0x04, 0xc0, 0x7c, 0x27, 0xbf, 0x34, 0xd6, 0x98, 0xef, 0xc4,
	0xe1, 0x5d, 0xd0, 0x93, 0x96, 0x9b, 0x19, 0x50, 0x90, 0x9e, 0x97, 0x7d, 0x68, 0x2e, 0x67, 0x4f,
	0x93, 0x74, 0xa3, 0x34, 0x52, 0x58, 0x13, 0x33, 0xea, 0xcb, 0x79, 0xf5, 0xfb, 0xd0, 0xcc, 0xef,
	0xbe, 0xd0, 0xac, 0xb4, 0x8b, 0xdd, 0x92, 0xd5, 0xc8, 0x2d, 0xbf, 0xf0, 0xe8, 0xf5, 0xe7, 0x9b,
	0x96, 0x71, 0x7d, 0xd3, 0x32, 0xbe, 0xde, 0xb4, 0x8c, 0x8f, 0xb7, 0xad, 0x95, 0xeb, 0xdb, 0xd6,
	0xca, 0x97, 0xdb, 0xd6, 0xca, 0xdb, 0xe7, 0x13, 0x0f, 0xdd, 0xd9, 0xa8, 0x67, 0xf3, 0xab, 0xbe,
	0x2d, 0x16, 0x01, 0xf2, 0x03, 0x2e, 0x26, 0x07, 0xca, 0x87, 0xbe, 0x2d, 0xb8, 0xcf, 0xc3, 0x7e,
	0x7c, 0x5d, 0x5f, 0x76, 0x6c, 0x38, 0x2a, 0xab, 0x75, 0xfc, 0xf2, 0x67, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x4a, 0xcf, 0x8d, 0x72, 0xec, 0x05, 0x00, 0x00,
}

func (m *EventBlockAttested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBlockAttested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBlockAttested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProcessedAt != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ProcessedAt))
		i--
		dAtA[i] = 0x38
	}
	if len(m.FinalityProof) > 0 {
		i -= len(m.FinalityProof)
		copy(dAtA[i:], m.FinalityProof)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.FinalityProof)))
		i--
		dAtA[i] = 0x32
	}
	if m.Finalized {
		i--
		if m.Finalized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0x22
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.AttestationId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.AttestationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventBlockFinalized) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBlockFinalized) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBlockFinalized) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttestationTxHash) > 0 {
		i -= len(m.AttestationTxHash)
		copy(dAtA[i:], m.AttestationTxHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AttestationTxHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FinalitySignature) > 0 {
		i -= len(m.FinalitySignature)
		copy(dAtA[i:], m.FinalitySignature)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.FinalitySignature)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ValidatorCount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ValidatorCount))
		i--
		dAtA[i] = 0x20
	}
	if m.FinalizedAt != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FinalizedAt))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventForcedTxSubmitted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventForcedTxSubmitted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventForcedTxSubmitted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubmittedAt != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SubmittedAt))
		i--
		dAtA[i] = 0x40
	}
	if m.Deadline != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Deadline))
		i--
		dAtA[i] = 0x38
	}
	if m.TxType != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.TxType))
		i--
		dAtA[i] = 0x30
	}
	if m.Priority != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TargetChainType) > 0 {
		i -= len(m.TargetChainType)
		copy(dAtA[i:], m.TargetChainType)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TargetChainType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TargetChainId) > 0 {
		i -= len(m.TargetChainId)
		copy(dAtA[i:], m.TargetChainId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TargetChainId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Submitter) > 0 {
		i -= len(m.Submitter)
		copy(dAtA[i:], m.Submitter)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Submitter)))
		i--
		dAtA[i] = 0x12
	}
	if m.ForcedTxId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ForcedTxId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventForcedTxExecuted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventForcedTxExecuted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventForcedTxExecuted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecutedAt != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ExecutedAt))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ExecutionHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ExecutionHeight))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ExecutionTxHash) > 0 {
		i -= len(m.ExecutionTxHash)
		copy(dAtA[i:], m.ExecutionTxHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExecutionTxHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TargetChainId) > 0 {
		i -= len(m.TargetChainId)
		copy(dAtA[i:], m.TargetChainId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TargetChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ForcedTxId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ForcedTxId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventBatchBlockAttested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBatchBlockAttested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBatchBlockAttested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttestationIds) > 0 {
		dAtA2 := make([]byte, len(m.AttestationIds)*10)
		var j1 int
		for _, num := range m.AttestationIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintEvents(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0x32
	}
	if m.FinalizedCount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FinalizedCount))
		i--
		dAtA[i] = 0x28
	}
	if m.BlockCount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockCount))
		i--
		dAtA[i] = 0x20
	}
	if m.EndHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.StartHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventBlockAttested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttestationId != 0 {
		n += 1 + sovEvents(uint64(m.AttestationId))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Finalized {
		n += 2
	}
	l = len(m.FinalityProof)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ProcessedAt != 0 {
		n += 1 + sovEvents(uint64(m.ProcessedAt))
	}
	return n
}

func (m *EventBlockFinalized) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	if m.FinalizedAt != 0 {
		n += 1 + sovEvents(uint64(m.FinalizedAt))
	}
	if m.ValidatorCount != 0 {
		n += 1 + sovEvents(uint64(m.ValidatorCount))
	}
	l = len(m.FinalitySignature)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AttestationTxHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventForcedTxSubmitted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForcedTxId != 0 {
		n += 1 + sovEvents(uint64(m.ForcedTxId))
	}
	l = len(m.Submitter)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TargetChainId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TargetChainType)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovEvents(uint64(m.Priority))
	}
	if m.TxType != 0 {
		n += 1 + sovEvents(uint64(m.TxType))
	}
	if m.Deadline != 0 {
		n += 1 + sovEvents(uint64(m.Deadline))
	}
	if m.SubmittedAt != 0 {
		n += 1 + sovEvents(uint64(m.SubmittedAt))
	}
	return n
}

func (m *EventForcedTxExecuted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForcedTxId != 0 {
		n += 1 + sovEvents(uint64(m.ForcedTxId))
	}
	l = len(m.TargetChainId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ExecutionTxHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ExecutionHeight != 0 {
		n += 1 + sovEvents(uint64(m.ExecutionHeight))
	}
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ExecutedAt != 0 {
		n += 1 + sovEvents(uint64(m.ExecutedAt))
	}
	return n
}

func (m *EventBatchBlockAttested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.StartHeight != 0 {
		n += 1 + sovEvents(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovEvents(uint64(m.EndHeight))
	}
	if m.BlockCount != 0 {
		n += 1 + sovEvents(uint64(m.BlockCount))
	}
	if m.FinalizedCount != 0 {
		n += 1 + sovEvents(uint64(m.FinalizedCount))
	}
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.AttestationIds) > 0 {
		l = 0
		for _, e := range m.AttestationIds {
			l += sovEvents(uint64(e))
		}
		n += 1 + sovEvents(uint64(l)) + l
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventBlockAttested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBlockAttested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBlockAttested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			m.AttestationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttestationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Finalized = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalityProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinalityProof = append(m.FinalityProof[:0], dAtA[iNdEx:postIndex]...)
			if m.FinalityProof == nil {
				m.FinalityProof = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessedAt", wireType)
			}
			m.ProcessedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBlockFinalized) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBlockFinalized: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBlockFinalized: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedAt", wireType)
			}
			m.FinalizedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalizedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorCount", wireType)
			}
			m.ValidatorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalitySignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinalitySignature = append(m.FinalitySignature[:0], dAtA[iNdEx:postIndex]...)
			if m.FinalitySignature == nil {
				m.FinalitySignature = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationTxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationTxHash = append(m.AttestationTxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationTxHash == nil {
				m.AttestationTxHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventForcedTxSubmitted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventForcedTxSubmitted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventForcedTxSubmitted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcedTxId", wireType)
			}
			m.ForcedTxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForcedTxId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submitter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Submitter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetChainType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetChainType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxType", wireType)
			}
			m.TxType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxType |= ForcedTxType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			m.Deadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deadline |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			m.SubmittedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventForcedTxExecuted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventForcedTxExecuted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventForcedTxExecuted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcedTxId", wireType)
			}
			m.ForcedTxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForcedTxId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionTxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionTxHash = append(m.ExecutionTxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ExecutionTxHash == nil {
				m.ExecutionTxHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionHeight", wireType)
			}
			m.ExecutionHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutionHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutedAt", wireType)
			}
			m.ExecutedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBatchBlockAttested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBatchBlockAttested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBatchBlockAttested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockCount", wireType)
			}
			m.BlockCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedCount", wireType)
			}
			m.FinalizedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalizedCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttestationIds = append(m.AttestationIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEvents
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthEvents
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AttestationIds) == 0 {
					m.AttestationIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AttestationIds = append(m.AttestationIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
